{"ast":null,"code":"import { sicLifeKnowledge, insuranceProducts, branches, chatbotResponses } from './knowledgeBase';\n\n// Mock API endpoints (replace with real endpoints in production)\nconst API_URL = 'https://api.siclife.com';\n\n// Chat context to maintain conversation state\nlet chatContext = {\n  currentTopic: undefined,\n  userData: {},\n  conversationFlow: undefined\n};\n\n// Helper function to find relevant knowledge base items\nconst findRelevantKnowledge = query => {\n  const lowerQuery = query.toLowerCase();\n  const words = lowerQuery.split(' ').filter(word => word.length > 2);\n  return sicLifeKnowledge.filter(item => {\n    const matchScore = item.keywords.reduce((score, keyword) => {\n      if (words.some(word => keyword.includes(word))) score += 1;\n      return score;\n    }, 0);\n    return matchScore > 0;\n  }).sort((a, b) => {\n    const aScore = a.keywords.filter(k => words.some(w => k.includes(w))).length;\n    const bScore = b.keywords.filter(k => words.some(w => k.includes(w))).length;\n    return bScore - aScore;\n  });\n};\n\n// Utility functions for delays\nconst getTypingDelay = text => {\n  // Faster typing speed (characters per minute)\n  const typingSpeed = 800;\n  // Calculate delay based on message length (minimum 0.5 second, maximum 2 seconds)\n  return Math.min(Math.max(text.length / typingSpeed * 60 * 1000, 500), 2000);\n};\nconst getThinkingDelay = () => {\n  // Random delay between 0.5 and 1 second\n  return Math.floor(Math.random() * 500) + 500;\n};\n\n// Process user message and generate response\nexport const processMessage = async message => {\n  // Add thinking delay\n  await new Promise(resolve => setTimeout(resolve, getThinkingDelay()));\n  const lowerMessage = message.toLowerCase();\n  let response;\n\n  // Check for agent handoff request\n  if (lowerMessage.includes('speak to agent') || lowerMessage.includes('talk to human')) {\n    response = {\n      id: Date.now().toString(),\n      content: chatbotResponses.agentHandoff[0],\n      sender: 'agent',\n      timestamp: new Date(),\n      type: 'text',\n      metadata: {\n        requiresHandoff: true\n      }\n    };\n  }\n\n  // Check for quote request\n  if (lowerMessage.includes('quote') || lowerMessage.includes('estimate') || lowerMessage.includes('cost')) {\n    chatContext.currentTopic = 'quote';\n    chatContext.conversationFlow = {\n      step: 'start',\n      data: {}\n    };\n    response = {\n      id: Date.now().toString(),\n      content: 'I can help you get a quote. First, which type of insurance are you interested in?\\n\\n' + insuranceProducts.map(p => `- ${p.name}`).join('\\n'),\n      sender: 'agent',\n      timestamp: new Date(),\n      type: 'form',\n      metadata: {\n        formType: 'quote',\n        step: 'product-selection'\n      }\n    };\n  }\n\n  // Check for claim status\n  if (lowerMessage.includes('claim status') || lowerMessage.includes('track claim')) {\n    response = {\n      id: Date.now().toString(),\n      content: 'Please provide your claim reference number to check its status.',\n      sender: 'agent',\n      timestamp: new Date(),\n      type: 'form',\n      metadata: {\n        formType: 'claim-status'\n      }\n    };\n  }\n\n  // Check for policy status\n  if (lowerMessage.includes('policy status') || lowerMessage.includes('check policy')) {\n    response = {\n      id: Date.now().toString(),\n      content: 'Please provide your policy number to check its status.',\n      sender: 'agent',\n      timestamp: new Date(),\n      type: 'form',\n      metadata: {\n        formType: 'policy-status'\n      }\n    };\n  }\n\n  // Check for payment related queries\n  if (lowerMessage.includes('pay') || lowerMessage.includes('premium') || lowerMessage.includes('payment')) {\n    response = {\n      id: Date.now().toString(),\n      content: 'Here are our available payment methods:\\n\\n' + '1. Mobile Money (MTN, Vodafone, AirtelTigo)\\n' + '2. Bank Transfer\\n' + '3. Card Payment (Visa/MasterCard)\\n\\n' + 'Which payment method would you prefer?',\n      sender: 'agent',\n      timestamp: new Date(),\n      type: 'payment',\n      metadata: {\n        paymentOptions: true\n      }\n    };\n  }\n\n  // Check for branch/contact information\n  if (lowerMessage.includes('branch') || lowerMessage.includes('location') || lowerMessage.includes('contact')) {\n    const branchInfo = branches.map(b => `${b.name}\\nAddress: ${b.address}\\nPhone: ${b.phone}\\nEmail: ${b.email}\\n` + `Hours: ${b.workingHours.weekdays} (weekdays)`).join('\\n\\n');\n    response = {\n      id: Date.now().toString(),\n      content: `Here are our branch details:\\n\\n${branchInfo}`,\n      sender: 'agent',\n      timestamp: new Date(),\n      type: 'text',\n      metadata: {\n        branches: branches\n      }\n    };\n  }\n\n  // Search knowledge base for relevant information\n  const relevantInfo = findRelevantKnowledge(message);\n  if (relevantInfo.length > 0) {\n    response = {\n      id: Date.now().toString(),\n      content: relevantInfo[0].answer,\n      sender: 'agent',\n      timestamp: new Date(),\n      type: 'text',\n      metadata: {\n        category: relevantInfo[0].category,\n        relatedQuestions: relevantInfo[0].relatedQuestions\n      }\n    };\n  } else {\n    // Fallback response\n    response = {\n      id: Date.now().toString(),\n      content: chatbotResponses.fallback[Math.floor(Math.random() * chatbotResponses.fallback.length)],\n      sender: 'agent',\n      timestamp: new Date(),\n      type: 'text'\n    };\n  }\n\n  // Add typing delay based on response length\n  await new Promise(resolve => setTimeout(resolve, getTypingDelay(response.content)));\n  return response;\n};\n\n// Mock function for quote calculation\nexport const calculateQuote = data => {\n  const baseRate = 10;\n  const ageFactor = Math.floor(data.age / 10);\n  const coverageFactor = data.coverageAmount / 10000;\n  const healthFactor = data.hasMedicalConditions ? 1.5 : 1;\n  return baseRate * ageFactor * coverageFactor * healthFactor;\n};\n\n// Mock function for claim submission\nexport const submitClaim = async data => {\n  // Simulate API call\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  return `CLAIM-${Date.now()}`;\n};\n\n// Mock function for policy status check\nexport const checkPolicyStatus = async policyNumber => {\n  // Simulate API call\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  return {\n    policyNumber,\n    status: 'active',\n    nextPaymentDue: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n    premiumAmount: 250\n  };\n};\n\n// Mock function for claim status check\nexport const checkClaimStatus = async claimId => {\n  // Simulate API call\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  return {\n    claimId,\n    status: 'processing',\n    lastUpdated: new Date(),\n    nextSteps: 'Your claim is being reviewed by our claims department.'\n  };\n};","map":{"version":3,"names":["sicLifeKnowledge","insuranceProducts","branches","chatbotResponses","API_URL","chatContext","currentTopic","undefined","userData","conversationFlow","findRelevantKnowledge","query","lowerQuery","toLowerCase","words","split","filter","word","length","item","matchScore","keywords","reduce","score","keyword","some","includes","sort","a","b","aScore","k","w","bScore","getTypingDelay","text","typingSpeed","Math","min","max","getThinkingDelay","floor","random","processMessage","message","Promise","resolve","setTimeout","lowerMessage","response","id","Date","now","toString","content","agentHandoff","sender","timestamp","type","metadata","requiresHandoff","step","data","map","p","name","join","formType","paymentOptions","branchInfo","address","phone","email","workingHours","weekdays","relevantInfo","answer","category","relatedQuestions","fallback","calculateQuote","baseRate","ageFactor","age","coverageFactor","coverageAmount","healthFactor","hasMedicalConditions","submitClaim","checkPolicyStatus","policyNumber","status","nextPaymentDue","premiumAmount","checkClaimStatus","claimId","lastUpdated","nextSteps"],"sources":["C:/Users/Godso/new sic app/src/services/api.ts"],"sourcesContent":["import { Message, QuoteFormData, ClaimFormData, PolicyStatus, ClaimStatus, ChatContext } from '../types';\r\nimport { sicLifeKnowledge, insuranceProducts, branches, chatbotResponses } from './knowledgeBase';\r\n\r\n// Mock API endpoints (replace with real endpoints in production)\r\nconst API_URL = 'https://api.siclife.com';\r\n\r\n// Chat context to maintain conversation state\r\nlet chatContext: ChatContext = {\r\n  currentTopic: undefined,\r\n  userData: {},\r\n  conversationFlow: undefined\r\n};\r\n\r\n// Helper function to find relevant knowledge base items\r\nconst findRelevantKnowledge = (query: string): any[] => {\r\n  const lowerQuery = query.toLowerCase();\r\n  const words = lowerQuery.split(' ').filter(word => word.length > 2);\r\n  \r\n  return sicLifeKnowledge.filter(item => {\r\n    const matchScore = item.keywords.reduce((score, keyword) => {\r\n      if (words.some(word => keyword.includes(word))) score += 1;\r\n      return score;\r\n    }, 0);\r\n    return matchScore > 0;\r\n  }).sort((a, b) => {\r\n    const aScore = a.keywords.filter(k => words.some(w => k.includes(w))).length;\r\n    const bScore = b.keywords.filter(k => words.some(w => k.includes(w))).length;\r\n    return bScore - aScore;\r\n  });\r\n};\r\n\r\n// Utility functions for delays\r\nconst getTypingDelay = (text: string): number => {\r\n  // Faster typing speed (characters per minute)\r\n  const typingSpeed = 800;\r\n  // Calculate delay based on message length (minimum 0.5 second, maximum 2 seconds)\r\n  return Math.min(Math.max((text.length / typingSpeed) * 60 * 1000, 500), 2000);\r\n};\r\n\r\nconst getThinkingDelay = (): number => {\r\n  // Random delay between 0.5 and 1 second\r\n  return Math.floor(Math.random() * 500) + 500;\r\n};\r\n\r\n// Process user message and generate response\r\nexport const processMessage = async (message: string): Promise<Message> => {\r\n  // Add thinking delay\r\n  await new Promise(resolve => setTimeout(resolve, getThinkingDelay()));\r\n  \r\n  const lowerMessage = message.toLowerCase();\r\n  let response: Message;\r\n  \r\n  // Check for agent handoff request\r\n  if (lowerMessage.includes('speak to agent') || lowerMessage.includes('talk to human')) {\r\n    response = {\r\n      id: Date.now().toString(),\r\n      content: chatbotResponses.agentHandoff[0],\r\n      sender: 'agent',\r\n      timestamp: new Date(),\r\n      type: 'text',\r\n      metadata: { requiresHandoff: true }\r\n    };\r\n  }\r\n\r\n  // Check for quote request\r\n  if (lowerMessage.includes('quote') || lowerMessage.includes('estimate') || lowerMessage.includes('cost')) {\r\n    chatContext.currentTopic = 'quote';\r\n    chatContext.conversationFlow = { step: 'start', data: {} };\r\n    response = {\r\n      id: Date.now().toString(),\r\n      content: 'I can help you get a quote. First, which type of insurance are you interested in?\\n\\n' +\r\n               insuranceProducts.map(p => `- ${p.name}`).join('\\n'),\r\n      sender: 'agent',\r\n      timestamp: new Date(),\r\n      type: 'form',\r\n      metadata: { formType: 'quote', step: 'product-selection' }\r\n    };\r\n  }\r\n\r\n  // Check for claim status\r\n  if (lowerMessage.includes('claim status') || lowerMessage.includes('track claim')) {\r\n    response = {\r\n      id: Date.now().toString(),\r\n      content: 'Please provide your claim reference number to check its status.',\r\n      sender: 'agent',\r\n      timestamp: new Date(),\r\n      type: 'form',\r\n      metadata: { formType: 'claim-status' }\r\n    };\r\n  }\r\n\r\n  // Check for policy status\r\n  if (lowerMessage.includes('policy status') || lowerMessage.includes('check policy')) {\r\n    response = {\r\n      id: Date.now().toString(),\r\n      content: 'Please provide your policy number to check its status.',\r\n      sender: 'agent',\r\n      timestamp: new Date(),\r\n      type: 'form',\r\n      metadata: { formType: 'policy-status' }\r\n    };\r\n  }\r\n\r\n  // Check for payment related queries\r\n  if (lowerMessage.includes('pay') || lowerMessage.includes('premium') || lowerMessage.includes('payment')) {\r\n    response = {\r\n      id: Date.now().toString(),\r\n      content: 'Here are our available payment methods:\\n\\n' +\r\n               '1. Mobile Money (MTN, Vodafone, AirtelTigo)\\n' +\r\n               '2. Bank Transfer\\n' +\r\n               '3. Card Payment (Visa/MasterCard)\\n\\n' +\r\n               'Which payment method would you prefer?',\r\n      sender: 'agent',\r\n      timestamp: new Date(),\r\n      type: 'payment',\r\n      metadata: { paymentOptions: true }\r\n    };\r\n  }\r\n\r\n  // Check for branch/contact information\r\n  if (lowerMessage.includes('branch') || lowerMessage.includes('location') || lowerMessage.includes('contact')) {\r\n    const branchInfo = branches.map(b => \r\n      `${b.name}\\nAddress: ${b.address}\\nPhone: ${b.phone}\\nEmail: ${b.email}\\n` +\r\n      `Hours: ${b.workingHours.weekdays} (weekdays)`\r\n    ).join('\\n\\n');\r\n\r\n    response = {\r\n      id: Date.now().toString(),\r\n      content: `Here are our branch details:\\n\\n${branchInfo}`,\r\n      sender: 'agent',\r\n      timestamp: new Date(),\r\n      type: 'text',\r\n      metadata: { branches: branches }\r\n    };\r\n  }\r\n\r\n  // Search knowledge base for relevant information\r\n  const relevantInfo = findRelevantKnowledge(message);\r\n  if (relevantInfo.length > 0) {\r\n    response = {\r\n      id: Date.now().toString(),\r\n      content: relevantInfo[0].answer,\r\n      sender: 'agent',\r\n      timestamp: new Date(),\r\n      type: 'text',\r\n      metadata: { \r\n        category: relevantInfo[0].category,\r\n        relatedQuestions: relevantInfo[0].relatedQuestions\r\n      }\r\n    };\r\n  } else {\r\n    // Fallback response\r\n    response = {\r\n      id: Date.now().toString(),\r\n      content: chatbotResponses.fallback[Math.floor(Math.random() * chatbotResponses.fallback.length)],\r\n      sender: 'agent',\r\n      timestamp: new Date(),\r\n      type: 'text'\r\n    };\r\n  }\r\n\r\n  // Add typing delay based on response length\r\n  await new Promise(resolve => setTimeout(resolve, getTypingDelay(response.content)));\r\n  \r\n  return response;\r\n};\r\n\r\n// Mock function for quote calculation\r\nexport const calculateQuote = (data: QuoteFormData): number => {\r\n  const baseRate = 10;\r\n  const ageFactor = Math.floor(data.age / 10);\r\n  const coverageFactor = data.coverageAmount / 10000;\r\n  const healthFactor = data.hasMedicalConditions ? 1.5 : 1;\r\n  \r\n  return baseRate * ageFactor * coverageFactor * healthFactor;\r\n};\r\n\r\n// Mock function for claim submission\r\nexport const submitClaim = async (data: ClaimFormData): Promise<string> => {\r\n  // Simulate API call\r\n  await new Promise(resolve => setTimeout(resolve, 1000));\r\n  return `CLAIM-${Date.now()}`;\r\n};\r\n\r\n// Mock function for policy status check\r\nexport const checkPolicyStatus = async (policyNumber: string): Promise<PolicyStatus> => {\r\n  // Simulate API call\r\n  await new Promise(resolve => setTimeout(resolve, 1000));\r\n  return {\r\n    policyNumber,\r\n    status: 'active',\r\n    nextPaymentDue: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\r\n    premiumAmount: 250\r\n  };\r\n};\r\n\r\n// Mock function for claim status check\r\nexport const checkClaimStatus = async (claimId: string): Promise<ClaimStatus> => {\r\n  // Simulate API call\r\n  await new Promise(resolve => setTimeout(resolve, 1000));\r\n  return {\r\n    claimId,\r\n    status: 'processing',\r\n    lastUpdated: new Date(),\r\n    nextSteps: 'Your claim is being reviewed by our claims department.'\r\n  };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}