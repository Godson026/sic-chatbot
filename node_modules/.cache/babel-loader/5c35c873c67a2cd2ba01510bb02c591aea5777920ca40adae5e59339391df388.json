{"ast":null,"code":"import { sicLifeKnowledge } from './knowledgeBase';\nimport { responseMap, formatResponseWithConfidence, getFallbackResponse } from './responseService';\nimport { findBestResponseKey, getMatchConfidence } from './fuzzyMatcher';\n\n// Mock API endpoints (replace with real endpoints in production)\nconst API_URL = 'https://api.siclife.com';\n\n// Chat context to maintain conversation state\nlet chatContext = {\n  currentTopic: undefined,\n  userData: {},\n  conversationFlow: undefined\n};\nlet chatState = {\n  previousResponses: [],\n  lastMatchedKey: null\n};\n\n// Helper function to find relevant knowledge base items\nconst findRelevantKnowledge = query => {\n  const lowerQuery = query.toLowerCase();\n  const words = lowerQuery.split(' ').filter(word => word.length > 2);\n  return sicLifeKnowledge.filter(item => {\n    const matchScore = item.keywords.reduce((score, keyword) => {\n      if (words.some(word => keyword.includes(word))) score += 1;\n      return score;\n    }, 0);\n    return matchScore > 0;\n  }).sort((a, b) => {\n    const aScore = a.keywords.filter(k => words.some(w => k.includes(w))).length;\n    const bScore = b.keywords.filter(k => words.some(w => k.includes(w))).length;\n    return bScore - aScore;\n  });\n};\n\n// Utility functions for delays\nconst getTypingDelay = text => {\n  const baseDelay = 1000; // Minimum 1 second\n  const charsPerMinute = 300;\n  const delayPerChar = 60 * 1000 / charsPerMinute;\n  const delay = Math.min(text.length * delayPerChar, 3000); // Max 3 seconds\n  return Math.max(baseDelay, delay);\n};\nconst getThinkingDelay = () => {\n  return 1000 + Math.random() * 1000;\n};\n\n// Process user message and generate response\nexport const processMessage = async message => {\n  // Add thinking delay\n  await new Promise(resolve => setTimeout(resolve, getThinkingDelay()));\n\n  // Find best matching response using fuzzy matching\n  const matchedKey = findBestResponseKey(message);\n  const confidence = matchedKey ? getMatchConfidence(matchedKey, message) : 0;\n  let responseData;\n  if (matchedKey && confidence > 0.4) {\n    responseData = responseMap[matchedKey];\n    chatState.lastMatchedKey = matchedKey;\n  } else {\n    responseData = getFallbackResponse(message, chatState.previousResponses);\n  }\n\n  // Format response with confidence level\n  const formattedContent = formatResponseWithConfidence(responseData, confidence, true // Always show follow-up questions for better user guidance\n  );\n\n  // Update chat state\n  chatState.previousResponses.push(formattedContent);\n\n  // Keep only last 5 responses in history\n  if (chatState.previousResponses.length > 5) {\n    chatState.previousResponses.shift();\n  }\n\n  // Add typing delay based on response length\n  await new Promise(resolve => setTimeout(resolve, getTypingDelay(formattedContent)));\n\n  // Return a properly formatted Message object\n  return {\n    id: Date.now().toString(),\n    content: formattedContent,\n    sender: 'agent',\n    timestamp: new Date(),\n    type: 'text',\n    metadata: {\n      confidence,\n      category: matchedKey ? matchedKey.split('_')[0] : 'general',\n      hasFollowUp: Boolean(responseData.followUp)\n    }\n  };\n};\n\n// Mock function for quote calculation\nexport const calculateQuote = data => {\n  const baseRate = 10;\n  const ageFactor = Math.floor(data.age / 10);\n  const coverageFactor = data.coverageAmount / 10000;\n  const healthFactor = data.hasMedicalConditions ? 1.5 : 1;\n  return baseRate * ageFactor * coverageFactor * healthFactor;\n};\n\n// Mock function for claim submission\nexport const submitClaim = async data => {\n  // Simulate API call\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  return `CLAIM-${Date.now()}`;\n};\n\n// Mock function for policy status check\nexport const checkPolicyStatus = async policyNumber => {\n  // Simulate API call\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  return {\n    policyNumber,\n    status: 'active',\n    nextPaymentDue: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n    premiumAmount: 250\n  };\n};\n\n// Mock function for claim status check\nexport const checkClaimStatus = async claimId => {\n  // Simulate API call\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  return {\n    claimId,\n    status: 'processing',\n    lastUpdated: new Date(),\n    nextSteps: 'Your claim is being reviewed by our claims department.'\n  };\n};\n\n// Reset chat state (useful for testing or starting new conversations)\nexport const resetChatState = () => {\n  chatState = {\n    previousResponses: [],\n    lastMatchedKey: null\n  };\n};","map":{"version":3,"names":["sicLifeKnowledge","responseMap","formatResponseWithConfidence","getFallbackResponse","findBestResponseKey","getMatchConfidence","API_URL","chatContext","currentTopic","undefined","userData","conversationFlow","chatState","previousResponses","lastMatchedKey","findRelevantKnowledge","query","lowerQuery","toLowerCase","words","split","filter","word","length","item","matchScore","keywords","reduce","score","keyword","some","includes","sort","a","b","aScore","k","w","bScore","getTypingDelay","text","baseDelay","charsPerMinute","delayPerChar","delay","Math","min","max","getThinkingDelay","random","processMessage","message","Promise","resolve","setTimeout","matchedKey","confidence","responseData","formattedContent","push","shift","id","Date","now","toString","content","sender","timestamp","type","metadata","category","hasFollowUp","Boolean","followUp","calculateQuote","data","baseRate","ageFactor","floor","age","coverageFactor","coverageAmount","healthFactor","hasMedicalConditions","submitClaim","checkPolicyStatus","policyNumber","status","nextPaymentDue","premiumAmount","checkClaimStatus","claimId","lastUpdated","nextSteps","resetChatState"],"sources":["C:/Users/Godso/new sic app/src/services/api.ts"],"sourcesContent":["import { Message, QuoteFormData, ClaimFormData, PolicyStatus, ClaimStatus, ChatContext } from '../types';\r\nimport { sicLifeKnowledge, insuranceProducts, branches, chatbotResponses } from './knowledgeBase';\r\nimport { responseMap, formatResponseWithConfidence, getFallbackResponse } from './responseService';\r\nimport { findBestResponseKey, getMatchConfidence } from './fuzzyMatcher';\r\n\r\n// Mock API endpoints (replace with real endpoints in production)\r\nconst API_URL = 'https://api.siclife.com';\r\n\r\n// Chat context to maintain conversation state\r\nlet chatContext: ChatContext = {\r\n  currentTopic: undefined,\r\n  userData: {},\r\n  conversationFlow: undefined\r\n};\r\n\r\ninterface ChatState {\r\n  previousResponses: string[];\r\n  lastMatchedKey: string | null;\r\n}\r\n\r\nlet chatState: ChatState = {\r\n  previousResponses: [],\r\n  lastMatchedKey: null\r\n};\r\n\r\n// Helper function to find relevant knowledge base items\r\nconst findRelevantKnowledge = (query: string): any[] => {\r\n  const lowerQuery = query.toLowerCase();\r\n  const words = lowerQuery.split(' ').filter(word => word.length > 2);\r\n  \r\n  return sicLifeKnowledge.filter(item => {\r\n    const matchScore = item.keywords.reduce((score, keyword) => {\r\n      if (words.some(word => keyword.includes(word))) score += 1;\r\n      return score;\r\n    }, 0);\r\n    return matchScore > 0;\r\n  }).sort((a, b) => {\r\n    const aScore = a.keywords.filter(k => words.some(w => k.includes(w))).length;\r\n    const bScore = b.keywords.filter(k => words.some(w => k.includes(w))).length;\r\n    return bScore - aScore;\r\n  });\r\n};\r\n\r\n// Utility functions for delays\r\nconst getTypingDelay = (text: string): number => {\r\n  const baseDelay = 1000; // Minimum 1 second\r\n  const charsPerMinute = 300;\r\n  const delayPerChar = (60 * 1000) / charsPerMinute;\r\n  const delay = Math.min(text.length * delayPerChar, 3000); // Max 3 seconds\r\n  return Math.max(baseDelay, delay);\r\n};\r\n\r\nconst getThinkingDelay = (): number => {\r\n  return 1000 + Math.random() * 1000;\r\n};\r\n\r\n// Process user message and generate response\r\nexport const processMessage = async (message: string): Promise<Message> => {\r\n  // Add thinking delay\r\n  await new Promise(resolve => setTimeout(resolve, getThinkingDelay()));\r\n\r\n  // Find best matching response using fuzzy matching\r\n  const matchedKey = findBestResponseKey(message);\r\n  const confidence = matchedKey ? getMatchConfidence(matchedKey, message) : 0;\r\n\r\n  let responseData;\r\n  if (matchedKey && confidence > 0.4) {\r\n    responseData = responseMap[matchedKey];\r\n    chatState.lastMatchedKey = matchedKey;\r\n  } else {\r\n    responseData = getFallbackResponse(message, chatState.previousResponses);\r\n  }\r\n\r\n  // Format response with confidence level\r\n  const formattedContent = formatResponseWithConfidence(\r\n    responseData,\r\n    confidence,\r\n    true // Always show follow-up questions for better user guidance\r\n  );\r\n\r\n  // Update chat state\r\n  chatState.previousResponses.push(formattedContent);\r\n  \r\n  // Keep only last 5 responses in history\r\n  if (chatState.previousResponses.length > 5) {\r\n    chatState.previousResponses.shift();\r\n  }\r\n\r\n  // Add typing delay based on response length\r\n  await new Promise(resolve => setTimeout(resolve, getTypingDelay(formattedContent)));\r\n\r\n  // Return a properly formatted Message object\r\n  return {\r\n    id: Date.now().toString(),\r\n    content: formattedContent,\r\n    sender: 'agent',\r\n    timestamp: new Date(),\r\n    type: 'text',\r\n    metadata: {\r\n      confidence,\r\n      category: matchedKey ? matchedKey.split('_')[0] : 'general',\r\n      hasFollowUp: Boolean(responseData.followUp)\r\n    }\r\n  };\r\n};\r\n\r\n// Mock function for quote calculation\r\nexport const calculateQuote = (data: QuoteFormData): number => {\r\n  const baseRate = 10;\r\n  const ageFactor = Math.floor(data.age / 10);\r\n  const coverageFactor = data.coverageAmount / 10000;\r\n  const healthFactor = data.hasMedicalConditions ? 1.5 : 1;\r\n  \r\n  return baseRate * ageFactor * coverageFactor * healthFactor;\r\n};\r\n\r\n// Mock function for claim submission\r\nexport const submitClaim = async (data: ClaimFormData): Promise<string> => {\r\n  // Simulate API call\r\n  await new Promise(resolve => setTimeout(resolve, 1000));\r\n  return `CLAIM-${Date.now()}`;\r\n};\r\n\r\n// Mock function for policy status check\r\nexport const checkPolicyStatus = async (policyNumber: string): Promise<PolicyStatus> => {\r\n  // Simulate API call\r\n  await new Promise(resolve => setTimeout(resolve, 1000));\r\n  return {\r\n    policyNumber,\r\n    status: 'active',\r\n    nextPaymentDue: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\r\n    premiumAmount: 250\r\n  };\r\n};\r\n\r\n// Mock function for claim status check\r\nexport const checkClaimStatus = async (claimId: string): Promise<ClaimStatus> => {\r\n  // Simulate API call\r\n  await new Promise(resolve => setTimeout(resolve, 1000));\r\n  return {\r\n    claimId,\r\n    status: 'processing',\r\n    lastUpdated: new Date(),\r\n    nextSteps: 'Your claim is being reviewed by our claims department.'\r\n  };\r\n};\r\n\r\n// Reset chat state (useful for testing or starting new conversations)\r\nexport const resetChatState = () => {\r\n  chatState = {\r\n    previousResponses: [],\r\n    lastMatchedKey: null\r\n  };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}