{"ast":null,"code":"// Define conversation context\n\n// Initialize context\nlet context = {\n  previousQuestions: []\n};\n\n// Response templates with context awareness\nconst RESPONSES = {\n  greeting: [\"Hello! How can I help you today?\", \"Hi there! What can I do for you?\", \"Greetings! How may I assist you?\"],\n  farewell: [\"Goodbye! Have a great day!\", \"See you later! Take care!\", \"Bye! Feel free to come back if you need more help!\"],\n  thanks: [\"You're welcome!\", \"Glad I could help!\", \"My pleasure! Is there anything else you need?\"],\n  name: [\"Nice to meet you! I'll remember your name.\", \"That's a great name! I'm happy to know you.\", \"Thanks for introducing yourself!\"],\n  mood_positive: [\"I'm glad you're feeling good!\", \"That's wonderful to hear!\", \"Your positive energy is contagious!\"],\n  mood_negative: [\"I'm sorry to hear that. Is there anything I can do to help?\", \"That sounds challenging. Would you like to talk about it?\", \"I'm here to listen if you need someone to talk to.\"],\n  default: [\"I'm not sure I understand. Could you rephrase that?\", \"I'm still learning. Could you try asking in a different way?\", \"I'm not sure about that. Can you provide more details?\"]\n};\n\n// Extract name from message\nconst extractName = message => {\n  const nameMatch = message.match(/my name is ([a-zA-Z]+)/i);\n  return nameMatch ? nameMatch[1] : null;\n};\n\n// Detect mood from message\nconst detectMood = message => {\n  const positiveWords = ['happy', 'good', 'great', 'awesome', 'excellent', 'wonderful', 'amazing'];\n  const negativeWords = ['sad', 'bad', 'terrible', 'awful', 'horrible', 'angry', 'frustrated'];\n  const lowerMessage = message.toLowerCase();\n  for (const word of positiveWords) {\n    if (lowerMessage.includes(word)) return 'positive';\n  }\n  for (const word of negativeWords) {\n    if (lowerMessage.includes(word)) return 'negative';\n  }\n  return 'neutral';\n};\n\n// Get response type based on message content and context\nconst getResponseType = message => {\n  const lowerMessage = message.toLowerCase();\n\n  // Check for name introduction\n  if (lowerMessage.match(/my name is/i)) {\n    return 'name';\n  }\n\n  // Check for greetings\n  if (lowerMessage.match(/^(hi|hello|hey|greetings)/)) {\n    return 'greeting';\n  }\n\n  // Check for farewells\n  if (lowerMessage.match(/^(bye|goodbye|see you|farewell)/)) {\n    return 'farewell';\n  }\n\n  // Check for thanks\n  if (lowerMessage.match(/^(thanks|thank you|appreciate it)/)) {\n    return 'thanks';\n  }\n\n  // Check mood\n  const mood = detectMood(message);\n  if (mood === 'positive') return 'mood_positive';\n  if (mood === 'negative') return 'mood_negative';\n  return 'default';\n};\n\n// Get a random response from the appropriate category\nconst getRandomResponse = type => {\n  const responses = RESPONSES[type];\n  return responses[Math.floor(Math.random() * responses.length)];\n};\n\n// Update context based on message\nconst updateContext = message => {\n  // Extract name if present\n  const name = extractName(message);\n  if (name) {\n    context.userName = name;\n  }\n\n  // Update mood\n  context.mood = detectMood(message);\n\n  // Add to previous questions\n  context.previousQuestions.push(message);\n\n  // Keep only last 5 questions\n  if (context.previousQuestions.length > 5) {\n    context.previousQuestions.shift();\n  }\n};\n\n// Generate personalized response\nconst generatePersonalizedResponse = response => {\n  if (context.userName) {\n    return response.replace(/you/i, context.userName);\n  }\n  return response;\n};\nexport const processMessage = async message => {\n  // Update context\n  updateContext(message);\n\n  // Get response type\n  const responseType = getResponseType(message);\n\n  // Get base response\n  let responseText = getRandomResponse(responseType);\n\n  // Personalize response\n  responseText = generatePersonalizedResponse(responseText);\n\n  // Simulate thinking time\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  return {\n    id: Date.now().toString(),\n    content: responseText,\n    sender: 'agent',\n    timestamp: new Date()\n  };\n};","map":{"version":3,"names":["context","previousQuestions","RESPONSES","greeting","farewell","thanks","name","mood_positive","mood_negative","default","extractName","message","nameMatch","match","detectMood","positiveWords","negativeWords","lowerMessage","toLowerCase","word","includes","getResponseType","mood","getRandomResponse","type","responses","Math","floor","random","length","updateContext","userName","push","shift","generatePersonalizedResponse","response","replace","processMessage","responseType","responseText","Promise","resolve","setTimeout","id","Date","now","toString","content","sender","timestamp"],"sources":["C:/Users/Godso/new sic app/src/services/chatbot.ts"],"sourcesContent":["import { Message } from '../types';\r\n\r\n// Define conversation context\r\ninterface ConversationContext {\r\n  lastTopic?: string;\r\n  userName?: string;\r\n  mood?: 'positive' | 'neutral' | 'negative';\r\n  previousQuestions: string[];\r\n}\r\n\r\n// Initialize context\r\nlet context: ConversationContext = {\r\n  previousQuestions: []\r\n};\r\n\r\n// Response templates with context awareness\r\nconst RESPONSES = {\r\n  greeting: [\r\n    \"Hello! How can I help you today?\",\r\n    \"Hi there! What can I do for you?\",\r\n    \"Greetings! How may I assist you?\"\r\n  ],\r\n  farewell: [\r\n    \"Goodbye! Have a great day!\",\r\n    \"See you later! Take care!\",\r\n    \"Bye! Feel free to come back if you need more help!\"\r\n  ],\r\n  thanks: [\r\n    \"You're welcome!\",\r\n    \"Glad I could help!\",\r\n    \"My pleasure! Is there anything else you need?\"\r\n  ],\r\n  name: [\r\n    \"Nice to meet you! I'll remember your name.\",\r\n    \"That's a great name! I'm happy to know you.\",\r\n    \"Thanks for introducing yourself!\"\r\n  ],\r\n  mood_positive: [\r\n    \"I'm glad you're feeling good!\",\r\n    \"That's wonderful to hear!\",\r\n    \"Your positive energy is contagious!\"\r\n  ],\r\n  mood_negative: [\r\n    \"I'm sorry to hear that. Is there anything I can do to help?\",\r\n    \"That sounds challenging. Would you like to talk about it?\",\r\n    \"I'm here to listen if you need someone to talk to.\"\r\n  ],\r\n  default: [\r\n    \"I'm not sure I understand. Could you rephrase that?\",\r\n    \"I'm still learning. Could you try asking in a different way?\",\r\n    \"I'm not sure about that. Can you provide more details?\"\r\n  ]\r\n};\r\n\r\n// Extract name from message\r\nconst extractName = (message: string): string | null => {\r\n  const nameMatch = message.match(/my name is ([a-zA-Z]+)/i);\r\n  return nameMatch ? nameMatch[1] : null;\r\n};\r\n\r\n// Detect mood from message\r\nconst detectMood = (message: string): 'positive' | 'neutral' | 'negative' => {\r\n  const positiveWords = ['happy', 'good', 'great', 'awesome', 'excellent', 'wonderful', 'amazing'];\r\n  const negativeWords = ['sad', 'bad', 'terrible', 'awful', 'horrible', 'angry', 'frustrated'];\r\n  \r\n  const lowerMessage = message.toLowerCase();\r\n  \r\n  for (const word of positiveWords) {\r\n    if (lowerMessage.includes(word)) return 'positive';\r\n  }\r\n  \r\n  for (const word of negativeWords) {\r\n    if (lowerMessage.includes(word)) return 'negative';\r\n  }\r\n  \r\n  return 'neutral';\r\n};\r\n\r\n// Get response type based on message content and context\r\nconst getResponseType = (message: string): keyof typeof RESPONSES => {\r\n  const lowerMessage = message.toLowerCase();\r\n  \r\n  // Check for name introduction\r\n  if (lowerMessage.match(/my name is/i)) {\r\n    return 'name';\r\n  }\r\n  \r\n  // Check for greetings\r\n  if (lowerMessage.match(/^(hi|hello|hey|greetings)/)) {\r\n    return 'greeting';\r\n  }\r\n  \r\n  // Check for farewells\r\n  if (lowerMessage.match(/^(bye|goodbye|see you|farewell)/)) {\r\n    return 'farewell';\r\n  }\r\n  \r\n  // Check for thanks\r\n  if (lowerMessage.match(/^(thanks|thank you|appreciate it)/)) {\r\n    return 'thanks';\r\n  }\r\n  \r\n  // Check mood\r\n  const mood = detectMood(message);\r\n  if (mood === 'positive') return 'mood_positive';\r\n  if (mood === 'negative') return 'mood_negative';\r\n  \r\n  return 'default';\r\n};\r\n\r\n// Get a random response from the appropriate category\r\nconst getRandomResponse = (type: keyof typeof RESPONSES): string => {\r\n  const responses = RESPONSES[type];\r\n  return responses[Math.floor(Math.random() * responses.length)];\r\n};\r\n\r\n// Update context based on message\r\nconst updateContext = (message: string) => {\r\n  // Extract name if present\r\n  const name = extractName(message);\r\n  if (name) {\r\n    context.userName = name;\r\n  }\r\n  \r\n  // Update mood\r\n  context.mood = detectMood(message);\r\n  \r\n  // Add to previous questions\r\n  context.previousQuestions.push(message);\r\n  \r\n  // Keep only last 5 questions\r\n  if (context.previousQuestions.length > 5) {\r\n    context.previousQuestions.shift();\r\n  }\r\n};\r\n\r\n// Generate personalized response\r\nconst generatePersonalizedResponse = (response: string): string => {\r\n  if (context.userName) {\r\n    return response.replace(/you/i, context.userName);\r\n  }\r\n  return response;\r\n};\r\n\r\nexport const processMessage = async (message: string): Promise<Message> => {\r\n  // Update context\r\n  updateContext(message);\r\n  \r\n  // Get response type\r\n  const responseType = getResponseType(message);\r\n  \r\n  // Get base response\r\n  let responseText = getRandomResponse(responseType);\r\n  \r\n  // Personalize response\r\n  responseText = generatePersonalizedResponse(responseText);\r\n  \r\n  // Simulate thinking time\r\n  await new Promise(resolve => setTimeout(resolve, 1000));\r\n  \r\n  return {\r\n    id: Date.now().toString(),\r\n    content: responseText,\r\n    sender: 'agent',\r\n    timestamp: new Date(),\r\n  };\r\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}